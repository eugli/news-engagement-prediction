{"organizations": [], "uuid": "9ee66b5ed81977e968f47308bae361cd7b64d340", "thread": {"social": {"gplus": {"shares": 15}, "pinterest": {"shares": 0}, "vk": {"shares": 0}, "linkedin": {"shares": 98}, "facebook": {"likes": 251, "shares": 251, "comments": 0}, "stumbledupon": {"shares": 0}}, "site_full": "nakedsecurity.sophos.com", "main_image": "https://sophosnews.files.wordpress.com/2017/02/shattered-1200.jpg?w=640", "site_section": "http://feeds.sophos.com/en/rss2_0-sophos-podcasts.xml", "section_title": "Naked Security - Sophos", "url": "https://nakedsecurity.sophos.com/2017/02/23/bang-sha-1-collides-at-38762cf7f55934b34d179ae6a4c80cadccbb7f0a/", "country": "GB", "domain_rank": 8261, "title": "Bang! SHA-1 collides at 38762cf7­f55934b3­4d179ae6­a4c80cad­ccbb7f0a", "performance_score": 2, "site": "sophos.com", "participants_count": 1, "title_full": "Bang! SHA-1 collides at 38762cf7­f55934b3­4d179ae6­a4c80cad­ccbb7f0a", "spam_score": 0.0, "site_type": "news", "published": "2017-02-24T01:57:00.000+02:00", "replies_count": 0, "uuid": "9ee66b5ed81977e968f47308bae361cd7b64d340"}, "author": "Paul Ducklin", "url": "https://nakedsecurity.sophos.com/2017/02/23/bang-sha-1-collides-at-38762cf7f55934b34d179ae6a4c80cadccbb7f0a/", "ord_in_thread": 0, "title": "Bang! SHA-1 collides at 38762cf7­f55934b3­4d179ae6­a4c80cad­ccbb7f0a", "locations": [], "entities": {"persons": [], "locations": [], "organizations": []}, "highlightText": "", "language": "english", "persons": [], "text": "Share on Twitter \nBack in the old days, “going online” meant calling up with your modem at 300 bits per second and interacting slowly with a basic command prompt (sometimes BASIC in the literal sense). \nNoise on the line and other electrical interference could easily turn zeros into ones and vice versa, causing corruption in your session, such as BANANA turned into BANAMA , MANGO into MaNGO , or even ONLINE into +++ATZ . \nA common way to spot obvious errors automatically was by using a checksum , quite literally calculated by checking the sum of all the numeric values of every byte in the message. \nChecksums were used because they were quick to calculate, as far back as the 1960s and 1970s, because even the most underpowered processors usually had an ADD or ACCUMULATE instruction that could efficiently maintain a running total of this sort. Sophos Home Learn More \nBut checksums were error prone. \nIf you swap round any of the bytes in a message, the checksum remains unchanged because A+B = B+A. \nLikewise, two errors can easily cancel out, for example if BANANA gets corrupted into CANAMA , because (A+1) + (B-1) = A+B. Enter the CRC \nCRCs, short for cyclic redundancy checks , were a better solution, using a comparatively simple series of bit-shifts and XOR operations to maintain a bigger accumulator that wasn’t so easily fooled by double errors or swapped bytes. \nCRC-32 produces a 32-bit (4-byte) checksum – today, the term checksum is used metaphorically, not literally to mean that the bytes were added together – designed to do a much better job of detecting accidental errors such as those caused by mistyping or by modem corruption. \nBut CRCs aren’t any good against deliberate errors. \nThat’s because CRCs are based on a process involving a form of long division, making the algorithm predictable, so the output can be tweaked to be whatever you like by tweaking the input slightly in a way that can be calculated automatically. \nThat makes it trivial to create a message with any checksum you like, for example so that its checksum matches an earlier message in order to create confusion, commit fraud, or worse. \nNote that there are only 4 billion (2 32 ) different possible CRC-32 values, so that at modern computer speeds you could forge a CRC-32 without any arithmetical trickery by brute force, simply by making billions of random modifications to the message until you hit paydirt. \nBut even if you extend your CRC to 64 bits, 128 bits or even more to make accidental duplicates as good as impossible, it’s still easy to calculate forgeries very quickly, with no need to rely on brute force. Moving up to cryptographic hashes \nFor security-related purposes, you need what’s commonly referred to as a cryptographic checksum or cryptographic hash . \nThis sort of algorithm is designed not only to detect accidental errors, but also to be “untrickable” enough to prevent deliberate errors. \nIn particular, a cryptographic hash, denoted here as a mathematical function H() , should have at least these characteristics: If you deliberately create two messages M1 and M2 (any two messages; you get to choose both of them) such that H(M1) = H(M2) , you have a collision, so that H has failed as a digital fingerprint. Therefore you should not be able to construct a collision , other than by trying over and over with different inputs until you hit the jackpot by chance. If you know that H(M) = X , but you don’t know my message M , then you should not be able to “go backwards” from X to M , other than by trying different messages over and over until you hit the jackpot by chance. If I choose M and tell you what it is, so you can compute H(M) = X for yourself, you should not be able to come up with a different message M’ that also has H(M’) = X , other than by guesswork. (This is much tougher than case 1 because you don’t get to choose any matching pair of hashes from a giant pool of messages. You have to match my hash, not any hash, which squares the effort needed.) \nFor many years, an algorithm called MD5 was widely used because it claimed to provide these three protections against abuse, but it is now forbidden in the cryptographic world because it is known to fail on Promise One above. \nOnce a hashing algorithm fails in respect of Promise One, it’s prudent to assume it won’t meet its other design goals either, even if it seems to be holding out on the other two promises. \nMD5 collisions are easy to generate on purpose, so the algorithm can no longer be trusted . SHA-1 replaces MD5 \nSHA-1 was the next-most-complex hash after MD5, and was widely used as a replacement when MD5 fell out of favour. \nGreatly oversimplified, the SHA-1 algorithm consumes its input in blocks of sixteen 32-bit words (512 bits, or 64 bytes), mixing each block into a cumulative hash of five 32-bit words (160 bits, or 20 bytes). for block in blocks() do for i = 17 to 80 do -- each step here extends the original 16-word input -- block to 80 words by adding one word made by mixing -- together four of the previous sixteen words. block[i] = minimixtogether(block,i) end for i = 1 to 80 do -- each step here mixes one of the words from the 80-word -- \"extended block\" into the five-byte hash accumulator hash = giantmixtogether(block,i) end end \nThe giantmixtogther() function that scrambles the extended input into the hash uses a range of different operations, including NOT, AND, OR, XOR, ADD and ROL (rotate left); the minimixtogether() function used to massage the input data uses XOR and ROL. \nThe algorithm certainly looks complicated, and at first glance you would assume that it mixes-minces-shreds-and-liquidises its input more than well enough to be “untrickable”. \nIndeed, the complexity of SHA-1 was considered sufficient to immunise it against the weaknesses in the similar but simpler MD5 algorithm. \nAt the same time, SHA-1 was not so much more complicated han MD5 that it would run too slowly to be a convenient replacement. SHA-1 considered harmful \nFor years, however, experts have been telling everyone to stop using SHA-1 , and to use more complex hash algorithms such as SHA-2 and SHA-3 instead, predicting that the first actual real-world, in-your-face chink in SHA-1’s armour would turn up soon. \nGoogle’s Chrome browser, for example, stopped accepting web site certificates with SHA-1 hashes at the start of 2017, considering them no longer safe enough. \nThe Mozilla Firefox browser will soon follow suit. \nThe reason is simple: as soon as someone actually turns theory into reality, and produces a hash collision, you can no longer rely on saying, “She’ll be right for a while yet,” because your “while yet” period just expired. \nSo it’s a good idea to get ahead of the game and to abandon creaky cryptographic code before it goes “Bang!” \nEven if a collision takes an enormous amount of work – imagine that you’d need 110 top-end graphics cards running flat out for a whole year, for example – the first actual collision would be what you might call the digital disproof of the pudding. The digital disproof \nSo, to cut what has become a long story short, you need to know that researchers from Google and the CWI Institute in Amsterdam… \n…have just disproved the pudding . \nBang! \nA hash collision that in theory should have taken them thousands of years to stumble upon by chance has been created on purpose within all of our lifetimes – and that should simply never have happened. \nApparently, they did indeed need 110 top-end graphics cards running for a whole year, but that is still 100,000 times faster than the design goals (and the theoretical strength) of SHA-1, making SHA-1 a risky proposition for evermore. \nTL;DR: SHA-1 really is broken, so use a stronger hash from now on, because cryptographic attacks only ever get faster.", "external_links": [], "published": "2017-02-24T01:57:00.000+02:00", "crawled": "2017-02-23T21:30:39.979+02:00", "highlightTitle": ""}