{"organizations": [], "uuid": "c90926d3bb54aa0cb9570e6ff354b5091bc3bd13", "thread": {"social": {"gplus": {"shares": 4}, "pinterest": {"shares": 0}, "vk": {"shares": 0}, "linkedin": {"shares": 27}, "facebook": {"likes": 221, "shares": 221, "comments": 0}, "stumbledupon": {"shares": 0}}, "site_full": "scotch.io", "main_image": "https://scotch.io/wp-content/uploads/2017/02/e4VS2LS8QPu2AlYzD3jJ_collage204.jpg", "site_section": "", "section_title": "", "url": "https://scotch.io/tutorials/retrogames-library-with-node-react-and-redux-1-server-api-and-react-frontend", "country": "IO", "domain_rank": 10551, "title": "Retrogames Library with Node, React, and Redux 1: Server API and React Frontend | Scotch", "performance_score": 2, "site": "scotch.io", "participants_count": 0, "title_full": "Retrogames Library with Node, React, and Redux 1: Server API and React Frontend | Scotch", "spam_score": 0.014, "site_type": "news", "published": "2017-02-23T17:51:00.000+02:00", "replies_count": 0, "uuid": "c90926d3bb54aa0cb9570e6ff354b5091bc3bd13"}, "author": "Samuele Zaza", "url": "https://scotch.io/tutorials/retrogames-library-with-node-react-and-redux-1-server-api-and-react-frontend", "ord_in_thread": 0, "title": "Retrogames Library with Node, React, and Redux 1: Server API and React Frontend | Scotch", "locations": [], "entities": {"persons": [{"name": "chai", "sentiment": "none"}, {"name": "filestack", "sentiment": "none"}, {"name": "samuele zaza", "sentiment": "none"}, {"name": "gameslistmanager", "sentiment": "none"}], "locations": [], "organizations": [{"name": "retrogames library", "sentiment": "negative"}, {"name": "picasa", "sentiment": "none"}]}, "highlightText": "", "language": "english", "persons": [], "text": "\n/containers/index.js \nAs we did for the components we create an index file to export the containers. Create it in /client/src/containers and paste the following code: import AddGameContainer from './AddGameContainer'; import GamesContainer from './GamesContainer'; // We export all the containers at once export { AddGameContainer, GamesContainer }; \nArchive.jsx \nas Home component, it just provides the layour and render the children. Create Archive.jsx in /client/src/components and paste the following code: import React, { PureComponent } from 'react'; import { Link } from 'react-router'; export default class Layout extends PureComponent { render () { return ( <div className=\"view\"><nav className=\"navbar navbar-inverse\"><div className=\"container\"><div className=\"navbar-header\"><button type=\"button\" className=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar\" aria-expanded=\"false\" aria-controls=\"navbar\"><span className=\"sr-only\">Toggle navigation</span><span className=\"icon-bar\" /><span className=\"icon-bar\" /><span className=\"icon-bar\" /></button><Link className=\"navbar-brand\" to=\"/\"><img src=\"https://cdn.filestackcontent.com/nLnmrZQaRpeythR4ezUo\" className=\"header-logo\" /></Link></div></div></nav> {this.props.children} <footer className=\"text-center\"><p>© 2016 Samuele Zaza</p></footer></div> ); } } \nGamesContainer.jsx \nThis is the container for the archive list where we are writing all the functions to manipulate the state. Let's first create the file and then comment it! Create GamesContainer.jsx in /client/src/containers and paste the following code: import React, { Component } from 'react'; import { Modal, GamesListManager } from '../components'; export default class GamesContainer extends Component { constructor (props) { super(props); // The initial state this.state = { games: [], selectedGame: {}, searchBar: '' }; // Bind the functions to this (context) this.toggleModal = this.toggleModal.bind(this); this.deleteGame = this.deleteGame.bind(this); this.setSearchBar = this.setSearchBar.bind(this); } // Once the component mounted it fetches the data from the server componentDidMount () { this.getGames(); } toggleModal (index) { this.setState({ selectedGame: this.state.games[index] }); // Since we included bootstrap we can show our modal through its syntax $('#game-modal').modal(); } getGames () { fetch('http://localhost:8080/games', { headers: new Headers({ 'Content-Type': 'application/json' }) }) .then(response => response.json()) // The json response to object literal .then(data => this.setState({ games: data })); } deleteGame (id) { fetch(`http://localhost:8080/games/${id}`, { headers: new Headers({ 'Content-Type': 'application/json', }), method: 'DELETE', }) .then(response => response.json()) .then(response => { // The game is also removed from the state thanks to the filter function this.setState({ games: this.state.games.filter(game => game._id !== id) }); console.log(response.message); }); } setSearchBar (event) { // Super still filters super mario thanks to toLowerCase this.setState({ searchBar: event.target.value.toLowerCase() }); } render () { const { games, selectedGame, searchBar } = this.state; return ( <div><Modal game={selectedGame} /><GamesListManager games={games} searchBar={searchBar} setSearchBar={this.setSearchBar} toggleModal={this.toggleModal} deleteGame={this.deleteGame} /></div> ); } } In the constructor we defined an inital state with an empty array of games that will be soon populated. selectedGame is the specific game to show in the bootstrap modal and searchBar is the search keyword to filter the games. In componentDidMount() we call game() which make an HTTP call for the games and set them into the state. Notice the new fetch() function. toggleModal() is passed as props to the GamesListManager component to set the current game in the state and toggle the modal. setSearchBar() updates the state with the current keyword. toLowerCase() guarantees our search is not case-sensitive. Finally, we render Modal and GamesListManager components. \nNB : At the present time thinking about refactoring isn't necessary as our code will substantially change with Redux. In fact we should be just focusing on making things work now! \nModal.jsx \nThis is another stateless component, just create it in /client/src/components and paste the following code: import React, { PureComponent } from 'react'; export default class Modal extends PureComponent { render () { const { _id, img, name, description, year, picture } = this.props.game; return( <div className=\"modal fade\" id=\"game-modal\" tabIndex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\"><div className=\"modal-dialog\" role=\"document\"><div className=\"modal-content\"><div className=\"modal-header\"><button type=\"button\" className=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">×</span></button><h4 className=\"modal-title\" id=\"myModalLabel\">{`${name} (${year})`}</h4></div><div className=\"modal-body\"><div><img src={picture} className=\"img-responsive img-big\" /></div><hr /><p>{description}</p></div><div className=\"modal-footer\"><button type=\"button\" className=\"btn btn-warning\" data-dismiss=\"modal\">Close</button></div></div></div></div> ); } } \nThere is nothing special here, we simply shows the game information in a fancy modal. \nGamesListManager.jsx \nThough stateless it is a more meaningful component. Create it in /client/src/components and paste the following code: import React, { PureComponent } from 'react'; import { Link } from 'react-router'; import Game from './Game'; export default class GamesListManager extends PureComponent { render () { const { games, searchBar, setSearchBar, toggleModal, deleteGame } = this.props; return ( <div className=\"container scrollable\"><div className=\"row text-left\"><Link to=\"/games/add\" className=\"btn btn-danger\">Add a new Game!</Link></div><div className=\"row\"><input type=\"search\" placeholder=\"Search by Name\" className=\"form-control search-bar\" onKeyUp={setSearchBar} /></div><div className=\"row\"> { // A Game is only shown if its name contains the string from the searchBar games .filter(game => game.name.toLowerCase().includes(searchBar)) .map((game, i) => { return ( <Game {...game} key={game._id} i={i} toggleModal={toggleModal} deleteGame={deleteGame} /> ); }) } </div><hr /></div> ); } } We could actually move out the search bar and create another component for it, however we won't use it anywhere else so there is no reusability involved. In the render function we map the games to a Game component and we do some basic filtering: We make sure the game name contains the keyword from the search bar \nGame.jsx \nThe game container is pretty immediate as well, create it into /client/src/components and paste the following code: import React, { PureComponent } from 'react'; import { Link } from 'react-router'; export default class Game extends PureComponent { render () { const { _id, i, name, description, picture, toggleModal, deleteGame } = this.props; return ( <div className=\"col-md-4\"><div className=\"thumbnail\"><div className=\"thumbnail-frame\"><img src={picture} alt=\"...\" className=\"img-responsive thumbnail-pic\" /></div><div className=\"caption\"><h5>{name}</h5><p className=\"description-thumbnail\">{`${description.substring(0, 150)}...`}</p><div className=\"btn-group\" role=\"group\" aria-label=\"...\"><button className=\"btn btn-success\" role=\"button\" onClick={() => toggleModal(i)}>View</button><button className=\"btn btn-danger\" role=\"button\" onClick={() => deleteGame(_id)}>Delete</button></div></div></div></div> ); } } \nThe buttons triggers the functions we wrote in GamesContainer : These were passed as props from GamesContainer to GamesListManager and finally to Game . \nAddGameContainer.jsx \nThe container is gonna render a form where our users can create games for the archive. Create the AddGameContainer.jsx in /client/src/containers and paste the following code: import React, { Component } from 'react'; import { hashHistory } from 'react-router'; import { Form } from '../components'; export default class AddGameContainer extends Component { constructor (props) { super(props); // Initial state this.state = { newGame: {}}; // Bind this (context) to the functions to be passed down to the children components this.submit = this.submit.bind(this); this.uploadPicture = this.uploadPicture.bind(this); this.setGame = this.setGame.bind(this); } submit () { // We create the newGame object to be posted to the server const newGame = Object.assign({}, { picture: $('#picture').attr('src') }, this.state.newGame); fetch('http://localhost:8080/games', { headers: new Headers({ 'Content-Type': 'application/json' }), method: 'POST', body: JSON.stringify(newGame) }) .then(response => response.json()) .then(data => { console.log(data.message); // We go back to the games list view hashHistory.push('/games'); }); } uploadPicture () { filepicker.pick ( { mimetype: 'image/*', // Cannot upload other files but images container: 'modal', services: ['COMPUTER', 'FACEBOOK', 'INSTAGRAM', 'URL', 'IMGUR', 'PICASA'], openTo: 'COMPUTER' // First choice to upload files from }, function (Blob) { console.log(JSON.stringify(Blob)); $('#picture').attr('src', Blob.url); }, function (FPError) { console.log(FPError.toString()); } ); } // We make sure to keep the state up-to-date to the latest input values setGame () { const newGame = { name: document.getElementById('name').value, description: document.getElementById('description').value, year: document.getElementById('year').value, picture: $('#picture').attr('src') }; this.setState({ newGame }); } render () { return <Form submit={this.submit} uploadPicture={this.uploadPicture} setGame={this.setGame} /> } } In the constructor we define an empty new game in the state. Thanks to setGame() we create its values whenever the user edit one of the inputs from the form (you will see it later). submit() sends the new game to the server through POST request. \nWhat about the upload() function? \nInside we run the pick() function from Filestack which prompts a modal a picture. If you take a look a the documentation for the function, we may have noticed that the first parameter is an option object for customizing our uploader: For example, if you don't want users to upload non-image files, well Filestack allows you to restrict the mimetype! I love the fact I can create in few minutes my uploader with custom options to fit my needs. For the current tutorial, I defined the option objects as following: The mimetype equal to image/* limits the upload to image files. We can choose to show either a modal or dialog uploading interfaces, I personally prefer the modal but you guys could try to customize it the way you like! What are the sources to upload from? Not just the user's device but there are plenty of other choices. In our case we define an array of all the allowed sources. Finally, among these choices above, we choose the computer as the default one. \nFinally, there are two functions, one for onSuccess and one for onError . Notice the Blob object parameter on onSuccess : This is returned by Filestack , it contains a bunch of information among which the image url! \nLet me show you an example: { \"url\":\"https://cdn.filestackcontent.com/CLGctDtSZiFbm4AKYTSX\", \"filename\":\"background.jpg\", \"mimetype\":\"image/jpeg\", \"size\":609038, \"id\":1, \"key\":\"w53urmDSga10ndZsOiE5_background.jpg\", \"container\":\"filestack-website-uploads\", \"client\":\"computer\", \"isWriteable\":true } \nFor more information don't hesitate to take a look at the documentation, the guys made a big effort to write very clear instructions. \nForm.jsx \nOur last component is Form, let's create it in /client/src/components (used to it yet?!) and paste the following code: import React, { PureComponent } from 'react'; import { Link } from 'react-router'; export default class Form extends PureComponent { render () { return ( <div className=\"row scrollable\"><div className=\"col-md-offset-2 col-md-8\"><div className=\"text-left\"><Link to=\"/games\" className=\"btn btn-info\">Back</Link></div><div className=\"panel panel-default\"><div className=\"panel-heading\"><h2 className=\"panel-title text-center\"> Add a Game! </h2></div><div className=\"panel-body\"><form name=\"product-form\" action=\"\" onSubmit={() => this.props.submit()} noValidate><div className=\"form-group text-left\"><label htmlFor=\"caption\">Name</label><input id=\"name\" type=\"text\" className=\"form-control\" placeholder=\"Enter the title\" onChange={() => this.props.setGame()} /></div><div className=\"form-group text-left\"><label htmlFor=\"description\">Description</label><textarea id=\"description\" type=\"text\" className=\"form-control\" placeholder=\"Enter the description\" rows=\"5\" onChange={() => this.props.setGame()} ></textarea></div><div className=\"form-group text-left\"><label htmlFor=\"price\">Year</label><input id=\"year\" type=\"number\" className=\"form-control\" placeholder=\"Enter the year\" onChange={() => this.props.setGame()} /></div><div className=\"form-group text-left\"><label htmlFor=\"picture\">Picture</label><div className=\"text-center dropup\"><button id=\"button-upload\" type=\"button\" className=\"btn btn-danger\" onClick={() => this.props.uploadPicture()}> Upload <span className=\"caret\" /></button></div></div><div className=\"form-group text-center\"><img id=\"picture\" className=\"img-responsive img-upload\" /></div><button type=\"submit\" className=\"btn btn-submit btn-block\">Submit</button></form></div></div></div></div> ); } } \nPretty straightforward! Whenever a users edit any form input, the onChange function update the state. \nUpdate /components/index.js \nThe components were all created but we have to update /client/src/components/index.js to export them all. Replace its code with the following: import About from './About'; import Contact from './Contact'; import Form from './Form'; import Game from './Game'; import GamesListManager from './GamesListManager'; import Home from './Home'; import Archive from './Archive'; import Modal from './Modal'; import Welcome from './Welcome'; // We export all the components at once export { About, Contact, Form, Game, GamesListManager, Home, Archive, Modal, Welcome }; \nAnd now we can run the app! We first start the api server: yarn api \nAnd if you haven't, webpack-dev-server: yarn start \nThis should work smoothly however we are still not serving the bundle from Node.js. We need to run another command: yarn build \nThis will create the bundle.js in the /dist folder... Now connect to http://localhost:8080 and the client is served from our real server instead. \nCongratulations for finishing the first part of the tutorial! \nConclusions \nIn this first part of the tutorial we went through the initial project configuration. \nWe first built the backend of the app, an API server with Node.js and Express. We also made a preliminary test with postman to doublecheck that everything works as expected. For a real-world app this is not exhaustive, if you a curious about testing, take a look at my previous post on testing Node.js with Mocha and Chai here on Scotch! \nThen we spent some time configuring Webpack to include javascript and css inside the same bundle file. Eventually we wrote React components to see the app in action. \nIn the next tutorial we are going to include Redux and related packages, we will see how easily we can manage the state if we separate it into a container. We will include lots of new packages, not just redux but redux-saga, redux-form... We will work with immutable data structure as well. \nStay tuned! Subscribe & get our FREE eBook Build Your First Node.js App Stalk Us ", "external_links": [], "published": "2017-02-23T17:51:00.000+02:00", "crawled": "2017-02-23T13:01:29.892+02:00", "highlightTitle": ""}